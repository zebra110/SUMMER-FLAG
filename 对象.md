### 对象的引用
如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。
```
var o1 = {};
var o2 = o1;

o1.a = 1;
o2.a // 1

o2.b = 2;
o1.b // 2
```
上面代码中，o1和o2指向同一个对象，因此为其中任何一个变量添加属性，另一个变量都可以读写该属性。

此时，如果取消某一个变量对于原对象的引用，不会影响到另一个变量。
```
var o1 = {};
var o2 = o1;

o1 = 1;
o2 // {}
```
上面代码中，o1和o2指向同一个对象，然后o1的值变为1，这时不会对o2产生影响，o2还是指向原来的那个对象。

但是，这种引用只局限于对象，对于原始类型的数据则是传值引用，也就是说，都是值的拷贝。
```
var x = 1;
var y = x;

x = 2;
y // 1
```
上面的代码中，当x的值发生变化后，y的值并不变，这就表示y和x并不是指向同一个内存地址。
### 表达式还是语句？
对象采用大括号表示，这导致了一个问题：如果行首是一个大括号，它到底是表达式还是语句？
```
{ foo: 123 }
```
J({ foo: 123})avaScript引擎读到上面这行代码，会发现可能有两种含义。第一种可能是，这是一个表达式，表示一个包含foo属性的对象；第二种可能是，这是一个语句，表示一个代码区块，里面有一个标签foo，指向表达式123。

为了避免这种歧义，JavaScript规定，如果行首是大括号，一律解释为语句（即代码块）。如果要解释为表达式（即对象），必须在大括号前加上圆括号。
```
({ foo: 123})
```
这种差异在eval语句中反映得最明显。
```
eval('{foo: 123}') // 123
eval('({foo: 123})') // {foo: 123}
```
检查变量是否声明
```
if ('a' in window) {
  // 变量 a 声明过
} else {
  // 变量 a 未声明
}
```
### 查看所有属性
```
var o = {
  key1: 1,
  key2: 2
};

Object.keys(o);
// ['key1', 'key2']
```
### delete命令
delete命令用于删除对象的属性，删除成功后返回true。
```
var o = {p: 1};
Object.keys(o) // ["p"]

delete o.p // true
o.p // undefined
Object.keys(o) // []
```
只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。
```
var o = Object.defineProperty({}, 'p', {
  value: 123,
  configurable: false
});

o.p // 123
delete o.p // false
```
另外，需要注意的是，delete命令只能删除对象本身的属性，无法删除继承的属性
最后，delete命令不能删除var命令声明的变量，只能用来删除属性。

### for...in循环有两个使用注意点。
它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性
它不仅遍历对象自身的属性，还遍历继承的属性。
###with语句
它的作用是操作同一个对象的多个属性时，提供一些书写的方便。
```
// 例一
with (o) {
  p1 = 1;
  p2 = 2;
}
// 等同于
o.p1 = 1;
o.p2 = 2;

// 例二
with (document.links[0]){
  console.log(href);
  console.log(title);
  console.log(style);
}
// 等同于
console.log(document.links[0].href);
console.log(document.links[0].title);
console.log(document.links[0].style);
```

注意，with区块内部的变量，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。这是因为with区块没有改变作用域，它的内部依然是当前作用域。
```
var o = {};

with (o) {
  x = "abc";
}

o.x // undefined
x // "abc"
```
上面代码中，对象o没有属性x，所以with区块内部对x的操作，等于创造了一个全局变量x。正确的写法应该是，先定义对象o的属性x，然后在with区块内操作它。
```
var o = {};
o.x = 1;

with (o) {
  x = 2;
}

o.x // 2
```
with区块内部，模板变量name可以被对象o的属性替换，而p依然是全局变量。这就是很多模板引擎的实现原理。
```
var o = {
  name: 'Alice'
};

var p = [];

with (o) {
  p.push('Hello ', name, '!');
};

p.join('') // "Hello Alice!"
```
##复习
JS中的对象拥有字面形式（比如var a = { .. }），和构造形式（比如var a = new Array(..)）。字面形式几乎总是首选，但在某些情况下，构造形式提供更多的构建选项。

许多人错误地声称“Javascript中的一切都是对象”，这是不对的。对象是6种（或7中，看你从哪个方面说）基本类型之一。对象有子类型，包括function，还可以被行为特化，比如[object Array]作为内部的标签表示子类型数组。

对象是键/值对的集合。通过.propName或["propName"]语法，值可以作为属性访问。不管属性什么时候被访问，引擎实际上会调用内部默认的[[Get]]操作（在设置值时调用[[Put]]操作），它不仅直接在对象上查找属性，在没有找到时还会遍历[[Prototype]]链（见第五章）。

属性有一些可以通过属性描述符控制的特定性质，比如writable和configurable。另外，对象拥有它的不可变性（它们的属性也有），可以通过使用Object.preventExtensions(..)，Object.seal(..)，和Object.freeze(..)来控制几种不同等级的不可变性。

属性不必非要包含值 —— 它们也可以是带有getter/setter的“访问器属性”。它们也可以是可枚举或不可枚举的，这控制它们是否会在for..in这样的循环迭代中出现。

你也可以使用ES6的for..of语法，在数据结构（数组，对象等）中迭代 值，它寻找一个内建或自定义的@@iterator对象，这个对象由一个next()方法组成，通过这个next()方法每次迭代一个数据。
